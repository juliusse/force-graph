const $ = require('jquery');
const _ = require('lodash');

const ListenableObject = require('../listenable-object');

class Node extends ListenableObject {
    constructor(id, name, { tags = [], constantAttributes = {} } = {}) {
        super();
        this.id = id;
        this.name = name;
        this._tags = _.keyBy(tags, t => t.id);
        this.constantAttributes = constantAttributes;

        this.edges = {};
        this.set('selected', false);
    }

    save() {
        return new Promise((res, rej) => {
            $.ajax({
                type: 'POST',
                url: '/node',
                dataType: 'json',
                success: res,
                data: JSON.stringify({ node: this.toJSON() }),
                contentType: 'application/json'
            });
        })
            .then(data => this.emitEvent('updated', data));
    }

    static fromJSON(json, tagCollection) {
        const tags = json.tags.map(tagName => tagCollection.getTagForName(tagName));
        const constantAttributes = json.constantAttributes;
        return new Node(json.id, json.name, { tags, constantAttributes });
    }

    toJSON() {
        const json = _.pick(this, ['id', 'name', 'tags', 'constantAttributes']);
        json.tags = json.tags.map(t => t.id);
        return json;
    }

    get tags() {
        return _.values(this._tags);
    }

    get selected() {
        return this.get('selected');
    }

    set selected(isSelected) {
        this.set('selected', isSelected);
    }

    deselect() {
        this.set('selected', false);
    }

    get highlighted() {
        return this.get('highlighted');
    }

    set highlighted(isHighlighted) {
        this.set('highlighted', isHighlighted);
    }


    updateTags(newTagNames, tagProvider) {
        const removedTags = [];
        const addedTags = [];

        newTagNames.forEach(tagName => {
            if (!this.tags.some(t => t.name === tagName)) {
                const tag = tagProvider.getTagForName(tagName);
                addedTags.push(tag);
                this.addTag(tag);
            }
        });

        this.tags.forEach(tag => {
            if (newTagNames.indexOf(tag.name) === -1) {
                removedTags.push(tag);
                this.removeTag(tag);
            }
        });

        return {
            addedTags,
            removedTags
        };
    }

    onNodeUpdate(node, { tagsToAdd, tagsToRemove }) {
        tagsToAdd.forEach(({ otherNode, tag }) => {
            const edge = this.getEdgeTo(otherNode) ||
                this.fileGraph.addEdge(this.id, otherNode);

            edge.addTag(tag);
        });

        tagsToRemove.forEach(({ otherNode, tag }) => this.getEdgeTo(otherNode).removeTag(tag));
    }

    getEdgeTo(nodeId) {
        return this.edges.find(edge =>
            edge.leftNode.id === nodeId || edge.rightNode.id === nodeId);
    }

    addTag(tag) {
        this._tags[tag.id] = tag;
        this.emitEvent('added:tag', tag);
    }

    removeTag(tag) {
        delete this._tags[tag.id];
        this.emitEvent('removed:tag', tag);
    }

    hasTag(tag) {
        return this._tags[tag.id] != null;
    }
}

module.exports = Node;