const _ = require('lodash');

const Node = require('./node');
const Edge = require('./edge');
const Tag = require('./tag');
const StaticAttribute = require('./staticAttribute');

const Config = require('../config');
const ListenableObject = require('../listenable-object');

class DataModel extends ListenableObject {
    constructor(config) {
        super();
        this._config = config;
        this._nodes = {};
        this._edges = {};
        this._tags = {};
        this._staticAttributes = {};
    }

    get config() {
        return this._config;
    }

    get nodes() {
        return _.values(this._nodes);
    }

    get tags() {
        return _.values(this._tags);
    }

    get staticAttributes() {
        return _.flatten(_.values(this._staticAttributes).map(obj => _.values(obj)));
    }

    get edges() {
        return _.values(this._edges);
    }

    addTag(tag) {
        if (this._tags[tag.id] != null) {
            return;
        }

        this._tags[tag.id] = tag;
        this.listenTo(tag, 'removed:node', this.onTagNodeRemoved);

        this.emitEvent('added:tag', tag);
    }

    removeTag(tag) {
        delete this._tags[tag.id];
        this.emitEvent('removed:tag', tag);
    }

    addNode(node) {
        if (this._nodes[node.id] != null) {
            return;
        }

        // testing
        if (this.nodes.length >= 50) {
            return;
        }

        this._nodes[node.id] = node;

        node.tags.forEach(tag => this.onNodeTagAdded(node, tag));
        node.staticAttributes.forEach(sa => this.onNodeStaticAttributeAdded(node, sa));

        this.listenTo(node, 'added:tag', this.onNodeTagAdded);
        this.listenTo(node, 'removed:tag', this.onNodeTagRemoved);
    }

    onNodeStaticAttributeAdded(node, staticAttribute) {
        staticAttribute.nodes.forEach(rightNode => {
            const edge = this.getEdgeFor(node, rightNode);
            edge.addStaticAttribute(staticAttribute);
        });
        staticAttribute.addNode(node);
    }

    onNodeTagAdded(node, tag) {
        tag.nodes.forEach(rightNode => {
            const edge = this.getEdgeFor(node, rightNode);
            edge.addTag(tag);
        });
        tag.addNode(node);
    }

    onNodeTagRemoved(node, tag) {
        tag.removeNode(node);
        tag.nodes.forEach(rightNode => {

            const edge = this.getEdgeFor(node, rightNode);
            edge.removeTag(tag);
            if (!edge.hasMeaning()) {
                this.removeEdge(edge);
            }
        });
    }

    onTagNodeRemoved(tag) {
        if (tag.nodes.length === 0) {
            this.removeTag(tag);
        }
    }

    getEdgeFor(leftNode, rightNode) {
        const edgeId = Edge.generateId(leftNode, rightNode);
        if (this._edges[edgeId] == null) {
            this._edges[edgeId] = new Edge(leftNode, rightNode);
            this.emitEvent('added:edge', this._edges[edgeId]);
        }

        return this._edges[edgeId];
    }

    removeEdge(edge) {
        delete this._edges[edge.id];
        this.emitEvent('removed:edge', edge);
    }

    getTagForName(tagName) {
        if (this._tags[tagName] == null) {
            this.addTag(new Tag(tagName, this._config.client.forces.types.sameTag));
        }

        return this._tags[tagName];
    }

    getStaticAttribute(group, value) {
        if (_.get(this._staticAttributes, [group, value], null) == null) {
            _.set(this._staticAttributes, [group, value], new StaticAttribute(group, value,
                this._config.client.forces.types.sameStaticAttribute));
        }

        return this._staticAttributes[group][value];
    }

    toJSON() {
        return {
            tags: this.tags.map(t => t.toJSON()),
            nodes: this.nodes.map(n => n.toJSON()),
            config: this._config,
        };
    }

    static loadFromJSON({ tags, nodes, config }) {
        const dataModel = new DataModel(config);
        tags.forEach(t => dataModel.addTag(Tag.fromJSON(t)));
        nodes.forEach(n => dataModel.addNode(Node.fromJSON(n, dataModel)));

        return dataModel;
    }

    static createNew() {
        return new DataModel(Config.getDefaultConfig());
    }
}

module.exports = DataModel;