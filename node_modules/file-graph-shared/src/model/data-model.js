const _ = require('lodash');
const { removeElement } = require('../utils');

const Node = require('./node');
const Edge = require('./edge');
const Tag = require('./tag');

const ListenableObject = require('../listenable-object');

class DataModel extends ListenableObject {
    constructor() {
        super();
        this._nodes = {};
        this._tags = {};
        this._nodes = {};
        this._edges = {};
        this.fileTagMap = {};
        this.filePathMap = {};
    }

    get nodes() {
        return _.values(this._nodes);
    }

    get tags() {
        return _.values(this._tags);
    }

    get edges() {
        return _.values(this._edges);
    }

    addTag(tag) {
        if (this._tags[tag.id] != null) {
            return;
        }

        this._tags[tag.id] = tag;
    }

    addNode(node) {
        if (this._nodes[node.id] != null) {
            return;
        }

        // testing
        if (this.nodes.length >= 50) {
            return;
        }

        this._nodes[node.id] = node;

        // TODO make dynamic for all types (currently onyly has "directory")
        const path = node.constantAttributes.directory;
        if (this.filePathMap[path] == null) {
            this.filePathMap[path] = [];
        }

        this.filePathMap[path].forEach((rightNode) => {
            const edge = new Edge(node, rightNode, {
                constantAttributes: node.constantAttributes
            });
            this._edges[edge.id] = edge;
        });
        this.filePathMap[path].push(node);

        node.tags.forEach(tag => this.onNodeTagAdded(node, tag));

        this.listenTo(node, 'added:tag', this.onNodeTagAdded);
        this.listenTo(node, 'removed:tag', this.onNodeTagRemoved);
    }

    onNodeTagAdded(node, tag) {
        tag.nodes.forEach(rightNode => {
            const edge = this.getEdgeFor(node, rightNode);
            edge.addTag(tag);
        });
        tag.addNode(node);
    }

    onNodeTagRemoved(node, tag) {
        tag.nodes.forEach(rightNode => {
            const edge = this.getEdgeFor(node, rightNode);
            edge.removeTag(tag);
            if(!edge.hasMeaning()) {
                this.removeEdge(edge);
            }
        });
        tag.removeNode(node);
    }

    getEdgeFor(leftNode, rightNode) {
        const edgeId = Edge.generateId(leftNode, rightNode);
        if (this._edges[edgeId] == null) {
            this._edges[edgeId] = new Edge(leftNode, rightNode);
            this.emitEvent('added:edge', this._edges[edgeId]);
        }

        return this._edges[edgeId];
    }

    removeEdge(edge) {
        delete this._edges[edge.id];
        this.emitEvent('removed:edge', edge);
    }

    updateNode(nodeWithChanges) {
        const node = this._nodes[nodeWithChanges.id];

        const removedTags = [];
        const addedTags = [];
        const newTags = nodeWithChanges.tags;

        newTags.forEach(tag => {
            if (file.tags.indexOf(tag) === -1) {
                addedTags.push(tag);
            }
        });

        file.tags.forEach(tag => {
            if (newTags.indexOf(tag) === -1) {
                removedTags.push(tag);
            }
        });

        const tagsToRemove = [];
        removedTags.forEach(tag => {
            this.fileTagMap[tag] =
                removeElement(this.fileTagMap[tag], file);

            this.fileTagMap[tag].forEach(otherFile => {

                const edgeId = generateEdgeId(file, otherFile);
                const edge = this._edges[edgeId];

                edge.tags = removeElement(edge.tags, tag);

                if (edge.tags.length === 0 && edge.path == null) {
                    delete this._edges[edgeId];
                }
                tagsToRemove.push({ otherFile: otherFile.getId(), tag });
            });
        });
        file.tags = newTags;


        const tagsToAdd = [];
        addedTags.forEach(tag => {
            if (this.fileTagMap[tag] == null) {
                this.fileTagMap[tag] = [];
            }

            this.fileTagMap[tag].forEach(rightFile => {
                const edgeId = generateEdgeId(nodeWithChanges, rightFile);
                if (this._edges[edgeId] == null) {
                    this._edges[edgeId] = {
                        leftNode: nodeWithChanges.getId(),
                        rightNode: rightFile.getId(),
                        tags: []
                    };
                }

                const edge = this._edges[edgeId];
                edge.tags.push(tag);
                tagsToAdd.push({ otherFile: rightFile.getId(), tag });
            });
            this.fileTagMap[tag].push(file);
        });

        return {
            tagsToAdd,
            tagsToRemove
        };
    }

    getTagForName(tagName) {
        if (this._tags[tagName] == null) {
            this.addTag(new Tag(tagName));
        }

        return this._tags[tagName];
    }

    toJSON() {
        return {
            tags: this.tags.map(t => t.toJSON()),
            nodes: this.nodes.map(n => n.toJSON()),
        };
    }

    static loadFromJSON({ tags, nodes }) {
        const dataModel = new DataModel();
        tags.forEach(t => dataModel.addTag(Tag.fromJSON(t)));
        nodes.forEach(n => dataModel.addNode(Node.fromJSON(n, {
            getTagForName: (name) => dataModel.getTagForName(name)
        })));

        return dataModel;
    }
}

module.exports = DataModel;