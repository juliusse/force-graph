const _ = require('lodash');
const { removeElement } = require('../utils');

const Node = require('./node');
const Edge = require('./edge');
const Tag = require('./tag');

const ListenableObject = require('../listenable-object');

class DataModel extends ListenableObject {
    constructor() {
        super();
        this._nodes = {};
        this._edges = {};
        this._tags = {};
        this.filePathMap = {};
    }

    get nodes() {
        return _.values(this._nodes);
    }

    get tags() {
        return _.values(this._tags);
    }

    get edges() {
        return _.values(this._edges);
    }

    addTag(tag) {
        if (this._tags[tag.id] != null) {
            return;
        }

        this._tags[tag.id] = tag;
        this.listenTo(tag, 'removed:node', this.onTagNodeRemoved);

        this.emitEvent('added:tag', tag);
    }

    removeTag(tag) {
        delete this._tags[tag.id];
        this.emitEvent('removed:tag', tag);
    }

    addNode(node) {
        if (this._nodes[node.id] != null) {
            return;
        }

        // testing
        if (this.nodes.length >= 50) {
            return;
        }

        this._nodes[node.id] = node;

        // TODO make dynamic for all types (currently onyly has "directory")
        const path = node.constantAttributes.directory;
        if (this.filePathMap[path] == null) {
            this.filePathMap[path] = [];
        }

        this.filePathMap[path].forEach((rightNode) => {
            const edge = new Edge(node, rightNode, {
                constantAttributes: node.constantAttributes
            });
            this._edges[edge.id] = edge;
        });
        this.filePathMap[path].push(node);

        node.tags.forEach(tag => this.onNodeTagAdded(node, tag));

        this.listenTo(node, 'added:tag', this.onNodeTagAdded);
        this.listenTo(node, 'removed:tag', this.onNodeTagRemoved);
    }

    onNodeTagAdded(node, tag) {
        tag.nodes.forEach(rightNode => {
            const edge = this.getEdgeFor(node, rightNode);
            edge.addTag(tag);
        });
        tag.addNode(node);
    }

    onNodeTagRemoved(node, tag) {
        tag.nodes.forEach(rightNode => {
            const edge = this.getEdgeFor(node, rightNode);
            edge.removeTag(tag);
            if(!edge.hasMeaning()) {
                this.removeEdge(edge);
            }
        });
        tag.removeNode(node);
    }

    onTagNodeRemoved(tag) {
        if(tag.nodes.length === 0) {
            this.removeTag(tag);
        }
    }

    getEdgeFor(leftNode, rightNode) {
        const edgeId = Edge.generateId(leftNode, rightNode);
        if (this._edges[edgeId] == null) {
            this._edges[edgeId] = new Edge(leftNode, rightNode);
            this.emitEvent('added:edge', this._edges[edgeId]);
        }

        return this._edges[edgeId];
    }

    removeEdge(edge) {
        delete this._edges[edge.id];
        this.emitEvent('removed:edge', edge);
    }

    getTagForName(tagName) {
        if (this._tags[tagName] == null) {
            this.addTag(new Tag(tagName));
        }

        return this._tags[tagName];
    }

    toJSON() {
        return {
            tags: this.tags.map(t => t.toJSON()),
            nodes: this.nodes.map(n => n.toJSON()),
        };
    }

    static loadFromJSON({ tags, nodes }) {
        const dataModel = new DataModel();
        tags.forEach(t => dataModel.addTag(Tag.fromJSON(t)));
        nodes.forEach(n => dataModel.addNode(Node.fromJSON(n, {
            getTagForName: (name) => dataModel.getTagForName(name)
        })));

        return dataModel;
    }
}

module.exports = DataModel;